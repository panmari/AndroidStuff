<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_31) on Thu Aug 16 22:12:15 CEST 2012 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Actor
</TITLE>

<META NAME="date" CONTENT="2012-08-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Actor";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Actor.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../ch/aplu/android/ConsoleActivity.html" title="class in ch.aplu.android"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?ch/aplu/android/Actor.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Actor.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ch.aplu.android</FONT>
<BR>
Class Actor</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>ch.aplu.android.Actor</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../ch/aplu/android/GGActorCollisionListener.html" title="interface in ch.aplu.android">GGActorCollisionListener</A>, <A HREF="../../../ch/aplu/android/GGBorderListener.html" title="interface in ch.aplu.android">GGBorderListener</A>, <A HREF="../../../ch/aplu/android/GGTileCollisionListener.html" title="interface in ch.aplu.android">GGTileCollisionListener</A>, java.util.EventListener</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../ch/aplu/jcardgame/CardActor.html" title="class in ch.aplu.jcardgame">CardActor</A>, <A HREF="../../../ch/aplu/jcardgame/CardCover.html" title="class in ch.aplu.jcardgame">CardCover</A>, <A HREF="../../../ch/aplu/android/GGButtonBase.html" title="class in ch.aplu.android">GGButtonBase</A>, <A HREF="../../../ch/aplu/android/TextActor.html" title="class in ch.aplu.android">TextActor</A>, <A HREF="../../../ch/aplu/android/ToolBarItem.html" title="class in ch.aplu.android">ToolBarItem</A>, <A HREF="../../../ch/aplu/android/Turtle.html" title="class in ch.aplu.android">Turtle</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Actor</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../ch/aplu/android/GGBorderListener.html" title="interface in ch.aplu.android">GGBorderListener</A>, <A HREF="../../../ch/aplu/android/GGActorCollisionListener.html" title="interface in ch.aplu.android">GGActorCollisionListener</A>, <A HREF="../../../ch/aplu/android/GGTileCollisionListener.html" title="interface in ch.aplu.android">GGTileCollisionListener</A></DL>
</PRE>

<P>
Class that holds sprite icons that plays the role of an actor in the
 game's game grid. The actor's image may only be positioned in the center of cells.
 (for even pixel unit cells/and or even pixel unit images, some rounding is necessary.)
 For one pixel unit cells, the actor image is positioned at the pixel coordinates.
 An actor may contain more than one sprite. This is useful if the appearence of the actor
 should change, while remaining the same actor (walking, speaking, flying, etc.).
 The sprites are referenced by an integer sprite id running from 0 up.
 All sprites of an actor are positioned at the same location with the
 same direction. At all times only one (or none) of the sprites is visible.
 If an actor is declared rotatable, the sprite images are rotated when the actor
 direction changes. To speed-up execution the images are preloaded
 into the Java heap when the actor is created. By default there are 60 different
 rotation images giving an angle resolution of  360 / 60 = 6 degrees.
 (This number may be changed by calling setNbRotSprites(int nbSprites) before 
 the first rotatable actor is created.)<br><br>

 Actors are partially active objects, animated by the same thread that runs the simulation loop. In
 every simulation cycle, the actor's act() method is called, where the user performs the
 desired action. This concept has the advantage that act() is called in a strict order
 (that can be modified) and by the same thread. This avoids concurrency problems that is an issue
 with fully active object where each object has its own thread. As a drawback all actors must
 be cooperative: act() must return quickly in order to give other actors the chance to act.
 If actors should not act synchronously, the execution may be skipped for
 a given number of simulation cycles by using individually setSlowDown()<br><br>

 A advanced collision detection mechanism for collisions betweeen actors or
 between an actor an a tile of a tile map is implemented.
 The collision may be detected using collision rectangles, collision circles,
 collision spots and for some collision types collisions of non-transparent
 image pixels. Collision rectangles, circles and spots may be placed
 at any desired position (rectangles and circles with specified size) relative
 to the sprite image. The collision area rotates when the sprites rotates.
 Much effort is investigated for a high speed implementation
 of the collision detection, using the SAT (Separating Axis Theorem)
 for rotated rectangle intersection.<br>
 To speed up the collision system, each actor defines actors or tiles that are
 candidates for collisions. Collisions are considered to be events and are
 notified by a registrated GGActorCollisionListener or a registrated
 GGTileCollisionListener<br><br>
 The collision check is performed in every simulation cycle and the collision
 event callback invoked by the game thread after actor's act() invocation.<br><br>

 Most methods only has an effect if the actor has been added to the GameGrid.<br><br>
 
 When auto zoom is enabled, the actor sprite images are zoomed according to
 the current zoom factor when they are loaded. The cell locations are not
 adapted automatically. Location.toReal() may be used to convert virtual
 coordinates to real coordinates.<br><br> 

 All public methods are synchronized to make them thread-safe.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ch/aplu/android/GameGrid.html" title="class in ch.aplu.android">GameGrid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#gameGrid">gameGrid</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The reference to the GameGrid instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#nbCycles">nbCycles</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The current number of simulation cycles since last reset.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor()">Actor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an actor with no sprite image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(android.graphics.Bitmap...)">Actor</A></B>(android.graphics.Bitmap...&nbsp;spriteImages)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an unrotatable actor based on one or several sprite images
 defined by the given bitmaps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(boolean, android.graphics.Bitmap...)">Actor</A></B>(boolean&nbsp;isRotatable,
      android.graphics.Bitmap...&nbsp;spriteImages)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an actor based on one several sprite images defined by the given
 bitmaps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(boolean, android.graphics.Bitmap)">Actor</A></B>(boolean&nbsp;isRotatable,
      android.graphics.Bitmap&nbsp;spriteImage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs actor based on the specified bitmap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(boolean, java.lang.String...)">Actor</A></B>(boolean&nbsp;isRotatable,
      java.lang.String...&nbsp;filenames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an actor based on one several sprite images.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(boolean, java.lang.String)">Actor</A></B>(boolean&nbsp;isRotatable,
      java.lang.String&nbsp;filename)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an actor based on the specified sprite image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(boolean, java.lang.String, int)">Actor</A></B>(boolean&nbsp;isRotatable,
      java.lang.String&nbsp;filename,
      int&nbsp;nbSprites)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an actor based on one or more sprite images.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(java.lang.String...)">Actor</A></B>(java.lang.String...&nbsp;filenames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an unrotatable actor based on several sprite images.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(java.lang.String)">Actor</A></B>(java.lang.String&nbsp;filename)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an unrotatable actor based on the specified sprite image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#Actor(java.lang.String, int)">Actor</A></B>(java.lang.String&nbsp;filename,
      int&nbsp;nbSprites)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an unrotatable actor based on one or more sprite images.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#act()">act</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty method called in every simulation iteration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addActorCollisionListener(ch.aplu.android.GGActorCollisionListener)">addActorCollisionListener</A></B>(<A HREF="../../../ch/aplu/android/GGActorCollisionListener.html" title="interface in ch.aplu.android">GGActorCollisionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a collision listener that reports collision events when
 actors collide.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addActorTouchListener(ch.aplu.android.GGActorTouchListener, int)">addActorTouchListener</A></B>(<A HREF="../../../ch/aplu/android/GGActorTouchListener.html" title="interface in ch.aplu.android">GGActorTouchListener</A>&nbsp;listener,
                      int&nbsp;touchEventMask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as addActorTouchListener(listener, touchEventMask, onTopOnly)
 with onTopOnly = false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addActorTouchListener(ch.aplu.android.GGActorTouchListener, int, boolean)">addActorTouchListener</A></B>(<A HREF="../../../ch/aplu/android/GGActorTouchListener.html" title="interface in ch.aplu.android">GGActorTouchListener</A>&nbsp;listener,
                      int&nbsp;touchEventMask,
                      boolean&nbsp;onTopOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a GGActionTouchListener to get notifications when the touch
 interacts with the actor touch area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addBorderListener(ch.aplu.android.GGBorderListener)">addBorderListener</A></B>(<A HREF="../../../ch/aplu/android/GGBorderListener.html" title="interface in ch.aplu.android">GGBorderListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers an GGBorderListener so that the callback method nearBorder() is called
 when the actor's location is on a cell at the border of the game grid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addCollisionActor(ch.aplu.android.Actor)">addCollisionActor</A></B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;partner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a partner actor that becomes a collision candidate, e.g. that
 is checked for collisions in every simulation cycle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addCollisionActors(java.util.ArrayList)">addCollisionActors</A></B>(java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt;&nbsp;partnerList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers all actors in a list as collision candidates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addCollisionTile(ch.aplu.android.Location)">addCollisionTile</A></B>(<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a tile location that becomes a collision candidate, e.g. that
 is checked for collisions in every simulation cycle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addCollisionTiles(java.util.ArrayList)">addCollisionTiles</A></B>(java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&gt;&nbsp;locationList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers all tile locations in a list as collision candidates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#addTileCollisionListener(ch.aplu.android.GGTileCollisionListener)">addTileCollisionListener</A></B>(<A HREF="../../../ch/aplu/android/GGTileCollisionListener.html" title="interface in ch.aplu.android">GGTileCollisionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a tile listener that reports collision events when actors
 and tiles collide.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#collide(ch.aplu.android.Actor, ch.aplu.android.Actor)">collide</A></B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor1,
        <A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty implementation of a GGActorCollisionListener called when the two actors collides.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#collide(ch.aplu.android.Actor, ch.aplu.android.Location)">collide</A></B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor,
        <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty implementation of a GGTileCollisionListener called when
 the an actor collides with a tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#delay(long)">delay</A></B>(long&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delay execution for the given amount of time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#displace(double)">displace</A></B>(double&nbsp;ds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increases the current double displace position in the 
 current direction to the given double distance and moves the actor 
 in the cell that contains the given coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ch/aplu/android/GGBackground.html" title="class in ch.aplu.android">GGBackground</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getBackground()">getBackground</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the GGBackground reference of the actor's game grid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getCollisionActors()">getCollisionActors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a list of partners that are collision candidates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getCollisionActorsInRange(double, java.lang.Class, int)">getCollisionActorsInRange</A></B>(double&nbsp;radius,
                          java.lang.Class&nbsp;clazz,
                          int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all collision candidates who belongs to a given class whose collision areas
 of the image with given sprite id intersects the circle with specified radius.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getCollisionTiles()">getCollisionTiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a list of tile locations that are collision candidates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getCurrentImage()">getCurrentImage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bitmap of the currently visible sprite picture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getDirection()">getDirection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getDirectionStart()">getDirectionStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the start direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ch/aplu/android/PointD.html" title="class in ch.aplu.android">PointD</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getDisplacePosition()">getDisplacePosition</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current displace position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getHeight(int)">getHeight</A></B>(int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height of the sprite with given id.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getIdVisible()">getIdVisible</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the id of the visible sprite.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getImage()">getImage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bitmap of the originally loaded sprite with
 id = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getImage(int)">getImage</A></B>(int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bitmap of the originally loaded sprite with
 given sprite id.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getIntDirection()">getIntDirection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current direction rounded to the next integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getLocation()">getLocation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current location (horizontal and vertical coordinates).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getLocationOffset()">getLocationOffset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the pixel offset in x- and y-direction relative to the current
 location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getLocationStart()">getLocationStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the start location (horizontal and vertical coordinates).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNbCycles()">getNbCycles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of simulation cycles since last reset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNbHorzCells()">getNbHorzCells</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns number of cells of actor's game grid in horizontal direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNbSprites()">getNbSprites</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns number of sprites.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNbVertCells()">getNbVertCells</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns number of cells of actor's game grid in vertical direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNeighbours(double)">getNeighbours</A></B>(double&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all actors in a specified distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNeighbours(double, java.lang.Class)">getNeighbours</A></B>(double&nbsp;distance,
              java.lang.Class&nbsp;clazz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all actors of specified class in a specified distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getNextMoveLocation()">getNextMoveLocation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the target location of the next move().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getPixelColor(android.graphics.Point)">getPixelColor</A></B>(android.graphics.Point&nbsp;pt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the color of the currently visible sprite image at given
 pixel position ((0,0) at upper left vertex, x-axis to the right,
 y-axis downwards).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getPixelLocation()">getPixelLocation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the location of the actor center in pixel coordinates taking
 into account the current location offset (default offset is 0).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getRotatedImage(android.graphics.Bitmap, double)">getRotatedImage</A></B>(android.graphics.Bitmap&nbsp;bitmap,
                double&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use GGBitmap.getRotatedImage instead. <A HREF="../../../ch/aplu/android/GGBitmap.html#getRotatedImage(android.graphics.Bitmap, double)"><CODE>GGBitmap.getRotatedImage(Bitmap bitmap, double angle)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../ch/aplu/android/GGVector.html" title="class in ch.aplu.android">GGVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getRotatedPosition(ch.aplu.android.GGVector, android.graphics.Point, double)">getRotatedPosition</A></B>(<A HREF="../../../ch/aplu/android/GGVector.html" title="class in ch.aplu.android">GGVector</A>&nbsp;position,
                   android.graphics.Point&nbsp;center,
                   double&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new position vector of given position vector
 rotated with given center point by given angle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getRotationIndex()">getRotationIndex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current rotation index for rotatable actors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getScaledImage(android.graphics.Bitmap, double, double)">getScaledImage</A></B>(android.graphics.Bitmap&nbsp;bitmap,
               double&nbsp;factor,
               double&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use GGBitmap.getScaledImage instead. <A HREF="../../../ch/aplu/android/GGBitmap.html#getScaledImage(android.graphics.Bitmap, double, double)"><CODE>GGBitmap.getScaledImage(Bitmap bitmap, double factor, double angle)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getScaledImage(double, double)">getScaledImage</A></B>(double&nbsp;factor,
               double&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as getScaledImage(int spriteId, double factor, double direction)
 with spriteId = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getScaledImage(int, double, double)">getScaledImage</A></B>(int&nbsp;spriteId,
               double&nbsp;factor,
               double&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the sprite image scaled by the given factor and rotated to the
 given direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getSlowDown()">getSlowDown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current slow down factor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getWidth(int)">getWidth</A></B>(int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width of the sprite with given id.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getX()">getX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current horizontal coordinate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getXStart()">getXStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x-coordinate of the start location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getY()">getY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current vertical coordinate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getYStart()">getYStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y-coordinate of the start location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;android.graphics.Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#getZoomedImage(android.graphics.Bitmap, double)">getZoomedImage</A></B>(android.graphics.Bitmap&nbsp;bitmap,
               double&nbsp;factor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use GGBitmap.getZoomedImage instead. <A HREF="../../../ch/aplu/android/GGBitmap.html#getZoomedImage(android.graphics.Bitmap, double)"><CODE>GGBitmap.getZoomedImage(Bitmap bitmap, double factor)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#hide()">hide</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns off the visiblity of this actor (all sprites are hidden, spriteId = -1).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isActEnabled()">isActEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if act() is invoked in every simulation cycle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isActorCollisionEnabled()">isActorCollisionEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if collision notification between actors is enabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isHorzMirror()">isHorzMirror</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the horizontal mirroring state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isInGrid()">isInGrid</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if the actor's location is inside the grid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isMoveValid()">isMoveValid</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if the next call of move() will put the actor in a cell
 inside the game grid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isNearBorder()">isNearBorder</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if the current location is on a border row or column.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isRemoved()">isRemoved</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if the actor has been removed (by calling removeSelf() or
 GameGrid.removeActor()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isRotatable()">isRotatable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the actor is rotatable or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isVertMirror()">isVertMirror</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the vertical mirroring state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#isVisible()">isVisible</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if the actor is visible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#move()">move</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a small grid (total number of cells <= 2500 = 50 * 50)
 moves to one of 8 neighbour cells in the current direction (compass directions 45 degrees wide).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#move(int)">move</A></B>(int&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the given distance in the current direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#nearBorder(ch.aplu.android.Actor, ch.aplu.android.Location)">nearBorder</A></B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor,
           <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty implementation of a BorderListener called when the actor is set into a border cell.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#removeSelf()">removeSelf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the given actor from the scene, so that act() is not called 
 any more.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty method called when the actor is added to the game grid, 
 the reset button is clicked or doReset() is called.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#rotate(ch.aplu.android.Location, double)">rotate</A></B>(<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;centerLoc,
       double&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the actor with given rotation center location by the given angle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#rotate(android.graphics.Point, double)">rotate</A></B>(android.graphics.Point&nbsp;center,
       double&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the actor with given rotation center point by given angle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActEnabled(boolean)">setActEnabled</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable/disable the invocation of act() in every simulation cycle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorCollisionEnabled(boolean)">setActorCollisionEnabled</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable/disable the detection of collisions with the actor collision candidates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchCircle(int, android.graphics.Point, int)">setActorTouchCircle</A></B>(int&nbsp;spriteId,
                    android.graphics.Point&nbsp;center,
                    int&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the circle (in pixel units) relative to the sprite image that is used for
 actor touch detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchCircle(android.graphics.Point, int)">setActorTouchCircle</A></B>(android.graphics.Point&nbsp;center,
                    int&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setActorTouchCircle(int spriteId, Point center, int radius)
 for all sprites of this actor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchEnabled(boolean)">setActorTouchEnabled</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable/disable the detection of actor touch interactions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchImage()">setActorTouchImage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setActorTouchImage(int spriteId) for all sprites of this actor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchImage(int)">setActorTouchImage</A></B>(int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the non-transparent pixels of the sprite image for
 actor touch detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchRectangle(int, android.graphics.Point, int, int)">setActorTouchRectangle</A></B>(int&nbsp;spriteId,
                       android.graphics.Point&nbsp;center,
                       int&nbsp;width,
                       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the rectangle (in pixel units) relative to the sprite image that is used for
 actor touch detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setActorTouchRectangle(android.graphics.Point, int, int)">setActorTouchRectangle</A></B>(android.graphics.Point&nbsp;center,
                       int&nbsp;width,
                       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setActorTouchRectangle(int spriteId, Rectangle rect)
 for all sprites of this actor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionCircle(int, android.graphics.Point, int)">setCollisionCircle</A></B>(int&nbsp;spriteId,
                   android.graphics.Point&nbsp;center,
                   int&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the circle (in pixel units) relative to the sprite image that is used for
 collision detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionCircle(android.graphics.Point, int)">setCollisionCircle</A></B>(android.graphics.Point&nbsp;center,
                   int&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setCollisionCircle(int spriteId, Point center, int radius)
 for spriteId = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionImage()">setCollisionImage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setCollisionImage(int spriteId) for spriteId = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionImage(int)">setCollisionImage</A></B>(int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects collision detection on non-transparent pixels of the image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionLine(int, android.graphics.Point, android.graphics.Point)">setCollisionLine</A></B>(int&nbsp;spriteId,
                 android.graphics.Point&nbsp;startPoint,
                 android.graphics.Point&nbsp;endPoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the line segment (in pixel units) relative to the sprite image that is used for
 collision detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionLine(android.graphics.Point, android.graphics.Point)">setCollisionLine</A></B>(android.graphics.Point&nbsp;startPoint,
                 android.graphics.Point&nbsp;endPoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setCollisionLine(int spriteId, Point startPoint, Point endPoint)
 for spriteId = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionRectangle(int, android.graphics.Point, int, int)">setCollisionRectangle</A></B>(int&nbsp;spriteId,
                      android.graphics.Point&nbsp;center,
                      int&nbsp;width,
                      int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the rectangle (in pixel units) relative to the sprite image that is used for
 collision detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionRectangle(android.graphics.Point, int, int)">setCollisionRectangle</A></B>(android.graphics.Point&nbsp;center,
                      int&nbsp;width,
                      int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setCollisionRectangle(int spriteId, Rectangle rect)
 for spriteId = 0</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionSpot(int, android.graphics.Point)">setCollisionSpot</A></B>(int&nbsp;spriteId,
                 android.graphics.Point&nbsp;spot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects the hot spot (in pixel units) relative to the sprite image that is used for
 collision detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setCollisionSpot(android.graphics.Point)">setCollisionSpot</A></B>(android.graphics.Point&nbsp;spot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setCollisionSpot(int spriteId, Point spot)
 for spriteId = 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setDirection(double)">setDirection</A></B>(double&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the moving direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setDirection(ch.aplu.android.Location.CompassDirection)">setDirection</A></B>(<A HREF="../../../ch/aplu/android/Location.CompassDirection.html" title="enum in ch.aplu.android">Location.CompassDirection</A>&nbsp;compassDir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the moving direction to the given compass direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setDisplacePosition(ch.aplu.android.PointD)">setDisplacePosition</A></B>(<A HREF="../../../ch/aplu/android/PointD.html" title="class in ch.aplu.android">PointD</A>&nbsp;displacePosition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current displace position and moves the actor in the cell that
 contains the given coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setHorzMirror(boolean)">setHorzMirror</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, the sprite image shown is mirrored horizontally.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setLocation(ch.aplu.android.Location)">setLocation</A></B>(<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns a new current location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setLocationOffset(android.graphics.Point)">setLocationOffset</A></B>(android.graphics.Point&nbsp;locationOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a pixel offset in x- any y-direction relative to the current
 location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setOnBottom()">setOnBottom</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the actor at the last place in the scene <b>of the actor's class</b>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setOnTop()">setOnTop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the actor at the first place in the scene <b>of the actor's class</b>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setPixelLocation(android.graphics.Point)">setPixelLocation</A></B>(android.graphics.Point&nbsp;imageCenter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the center of the actor to the given pixel coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setSlowDown(int)">setSlowDown</A></B>(int&nbsp;factor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Slows down the calling of act() by the given factor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setVertMirror(boolean)">setVertMirror</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, the sprite image shown is mirrored vertically.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setX(int)">setX</A></B>(int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns a new current horizontal cell coordinate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#setY(int)">setY</A></B>(int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns a new current vertical cell coordinate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#show()">show</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns on the visibility of the sprite with id 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#show(int)">show</A></B>(int&nbsp;spriteId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns on the visibility of the sprite with given id.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#showNextSprite()">showNextSprite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increases the id of the currently visible sprite and makes this
 sprite visible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#showPreviousSprite()">showPreviousSprite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decreases the id of the currently visible sprite and makes this
 sprite visible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ch/aplu/android/Actor.html#turn(double)">turn</A></B>(double&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns the moving direction by the given angle (clockwise for positive
 angles, counterclockwise for negative angles).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="gameGrid"><!-- --></A><H3>
gameGrid</H3>
<PRE>
public <A HREF="../../../ch/aplu/android/GameGrid.html" title="class in ch.aplu.android">GameGrid</A> <B>gameGrid</B></PRE>
<DL>
<DD>The reference to the GameGrid instance.
 Null if the actor is not yet added to the game grid.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nbCycles"><!-- --></A><H3>
nbCycles</H3>
<PRE>
public int <B>nbCycles</B></PRE>
<DL>
<DD>The current number of simulation cycles since last reset.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Actor(android.graphics.Bitmap...)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(android.graphics.Bitmap...&nbsp;spriteImages)</PRE>
<DL>
<DD>Constructs an unrotatable actor based on one or several sprite images
 defined by the given bitmaps.
 The spriteId starts from 0 and corresponds to the order of the given images.
 (Used to create an actor based on images defined on runtime.)
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>spriteImages</CODE> - references to Bitmaps that contains the sprite images</DL>
</DL>
<HR>

<A NAME="Actor(boolean, android.graphics.Bitmap)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(boolean&nbsp;isRotatable,
             android.graphics.Bitmap&nbsp;spriteImage)</PRE>
<DL>
<DD>Constructs actor based on the specified bitmap.
 (Used to create an actor based on an image defined on runtime.)
 If isRotatable is true, the actor is rotated when the direction changes.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>isRotatable</CODE> - if true, the actor's image may be rotated when the direction changes<DD><CODE>spriteImage</CODE> - reference to a Bitmap that contains the sprite image</DL>
</DL>
<HR>

<A NAME="Actor(boolean, android.graphics.Bitmap...)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(boolean&nbsp;isRotatable,
             android.graphics.Bitmap...&nbsp;spriteImages)</PRE>
<DL>
<DD>Constructs an actor based on one several sprite images defined by the given
 bitmaps.
 The spriteId starts from 0 and corresponds to the order of the given images.
 (Used to create an actor based on images defined on runtime.)
 If isRotatable is true, the actor is rotated when the direction changes.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>isRotatable</CODE> - if true, the actor's image may be rotated when the direction changes<DD><CODE>spriteImages</CODE> - references to Bitmaps that contains the sprite images</DL>
</DL>
<HR>

<A NAME="Actor()"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>()</PRE>
<DL>
<DD>Constructs an actor with no sprite image. Sometimes this is useful for
 dummy actors that are not shown but act only.
<P>
</DL>
<HR>

<A NAME="Actor(java.lang.String)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(java.lang.String&nbsp;filename)</PRE>
<DL>
<DD>Constructs an unrotatable actor based on the specified sprite image.<br>
 From the given filename the image file in searched in the following order:<br>
 - filename contains a colon : searched at URL in format http://... <br>
 - filename contains slash or backslash : search on sdcard ("/sdcard/" appended)<br>
 - otherwise if contains no dot, searched in app package, else search on sdcard<br>
 e.g. if neither a dot nor a slash, searched from res/drawable resource folder
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>filename</CODE> - the path or URL to the image file displayed for this actor</DL>
</DL>
<HR>

<A NAME="Actor(java.lang.String...)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(java.lang.String...&nbsp;filenames)</PRE>
<DL>
<DD>Constructs an unrotatable actor based on several sprite images.
 The spriteId starts from 0 and corresponds to the order of the given filenames. 
 From the given filename the image file in searched in the following order:<br>
 - filename contains a colon : searched at URL in format http://... <br>
 - filename contains slash or backslash : search on sdcard ("/sdcard/" appended)<br>
 - otherwise if contains no dot, searched in app package, else search on sdcard<br>
 e.g. if neither a dot nor a slash, searched from res/drawable resource folder
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>filenames</CODE> - the paths or URLs (one or more) to the image files displayed for this actor</DL>
</DL>
<HR>

<A NAME="Actor(boolean, java.lang.String)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(boolean&nbsp;isRotatable,
             java.lang.String&nbsp;filename)</PRE>
<DL>
<DD>Constructs an actor based on the specified sprite image.
 If isRotatable is true, the actor is rotated when the direction changes.<br>
 From the given filename the image file in searched in the following order:<br>
 - filename contains a colon : searched at URL in format http://... <br>
 - filename contains slash or backslash : search on sdcard ("/sdcard/" appended)<br>
 - otherwise if contains no dot, searched in app package, else search on sdcard<br>
 e.g. if neither a dot nor a slash, searched from res/drawable resource folder
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>isRotatable</CODE> - if true, the actor's image may be rotated when the direction changes<DD><CODE>filename</CODE> - the path to the image file displayed for this actor</DL>
</DL>
<HR>

<A NAME="Actor(boolean, java.lang.String...)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(boolean&nbsp;isRotatable,
             java.lang.String...&nbsp;filenames)</PRE>
<DL>
<DD>Constructs an actor based on one several sprite images.
 If isRotatable is true, the actor is rotated when the direction changes.
 The spriteId starts from 0 and corresponds to the order of the given filenames.
 From the given filename the image file in searched in the following order:<br>
 - filename contains a colon : searched at URL in format http://... <br>
 - filename contains slash or backslash : search on sdcard ("/sdcard/" appended)<br>
 - otherwise if contains no dot, searched in app package, else search on sdcard<br>
 e.g. if neither a dot nor a slash, searched from res/drawable resource folder
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>isRotatable</CODE> - if true, the actor's image may be rotated when the direction changes<DD><CODE>filenames</CODE> - the paths or URLs to the image files displayed for this actor</DL>
</DL>
<HR>

<A NAME="Actor(java.lang.String, int)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(java.lang.String&nbsp;filename,
             int&nbsp;nbSprites)</PRE>
<DL>
<DD>Constructs an unrotatable actor based on one or more sprite images.
 The actor may contain more than one sprite images, if nbSprites > 1
 the filenames of these images are automatically generated in a sequence
 filename_0.ext, filename_1.ext, ...<br>
 From the given filename the image file in searched in the following order:<br>
 - filename contains a colon : searched at URL in format http://... <br>
 - filename contains slash or backslash : search on sdcard ("/sdcard/" appended)<br>
 - otherwise if contains no dot, searched in app package, else search on sdcard<br>
 e.g. if neither a dot nor a slash, searched from res/drawable resource folder
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>filename</CODE> - the fully qualified path to the image file displayed for this actor<DD><CODE>nbSprites</CODE> - the number of sprite images for the same actor</DL>
</DL>
<HR>

<A NAME="Actor(boolean, java.lang.String, int)"><!-- --></A><H3>
Actor</H3>
<PRE>
public <B>Actor</B>(boolean&nbsp;isRotatable,
             java.lang.String&nbsp;filename,
             int&nbsp;nbSprites)</PRE>
<DL>
<DD>Constructs an actor based on one or more sprite images.
 If isRotatable is true, the actor is rotated when the direction changes.
 The actor may contain more than one sprite images, if nbSprites > 1
 the filenames of these images are automatically generated in a sequence
 filename_0.ext, filename_1.ext, ...<br>
 From the given filename the image file in searched in the following order:<br>
 - filename contains a colon : searched at URL in format http://... <br>
 - filename contains slash or backslash : search on sdcard ("/sdcard/" appended)<br>
 - otherwise if contains no dot, searched in app package, else search on sdcard<br>
 e.g. if neither a dot nor a slash, searched from res/drawable resource folder
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>isRotatable</CODE> - if true, the actor's image may be rotated when the direction changes<DD><CODE>filename</CODE> - the path or URL to the image file displayed for this actor<DD><CODE>nbSprites</CODE> - the number of sprite images for the same actor</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setLocationOffset(android.graphics.Point)"><!-- --></A><H3>
setLocationOffset</H3>
<PRE>
public void <B>setLocationOffset</B>(android.graphics.Point&nbsp;locationOffset)</PRE>
<DL>
<DD>Sets a pixel offset in x- any y-direction relative to the current
 location. Effects the display position and the actorTouchArea only.
 All location values (e.g. getLocation(), collisionAreas, etc.) are unchanged.
 Used to fine tune the displayed sprite position in a coarse game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>locationOffset</CODE> - x,y displacement (x to the left, y downwards)</DL>
</DD>
</DL>
<HR>

<A NAME="getLocationOffset()"><!-- --></A><H3>
getLocationOffset</H3>
<PRE>
public android.graphics.Point <B>getLocationOffset</B>()</PRE>
<DL>
<DD>Returns the pixel offset in x- and y-direction relative to the current
 location.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>x, y displacment</DL>
</DD>
</DL>
<HR>

<A NAME="getBackground()"><!-- --></A><H3>
getBackground</H3>
<PRE>
public <A HREF="../../../ch/aplu/android/GGBackground.html" title="class in ch.aplu.android">GGBackground</A> <B>getBackground</B>()</PRE>
<DL>
<DD>Returns the GGBackground reference of the actor's game grid.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the GGBackground reference of the actor's game grid.
 If the actor is not yet added to the game grid,
 displays an error and terminates application.</DL>
</DD>
</DL>
<HR>

<A NAME="setX(int)"><!-- --></A><H3>
setX</H3>
<PRE>
public void <B>setX</B>(int&nbsp;x)</PRE>
<DL>
<DD>Assigns a new current horizontal cell coordinate.
 The location may be outside the range of the cells inside the game grid.
 Triggers a border event, if the location is near the border.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x-coordinate (cell index)</DL>
</DD>
</DL>
<HR>

<A NAME="setY(int)"><!-- --></A><H3>
setY</H3>
<PRE>
public void <B>setY</B>(int&nbsp;y)</PRE>
<DL>
<DD>Assigns a new current vertical cell coordinate.
 The location may be outside the range of the cells inside the game grid.
 Triggers a border event, if the location is near the border.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>y</CODE> - the y-coordinate (cell index)</DL>
</DD>
</DL>
<HR>

<A NAME="setLocation(ch.aplu.android.Location)"><!-- --></A><H3>
setLocation</H3>
<PRE>
public void <B>setLocation</B>(<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</PRE>
<DL>
<DD>Assigns a new current location.
 Triggers a border event, if the location is near the border.
 The location may be outside the range of the cells inside the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - the new location (value copy)</DL>
</DD>
</DL>
<HR>

<A NAME="setPixelLocation(android.graphics.Point)"><!-- --></A><H3>
setPixelLocation</H3>
<PRE>
public void <B>setPixelLocation</B>(android.graphics.Point&nbsp;imageCenter)</PRE>
<DL>
<DD>Moves the center of the actor to the given pixel coordinates.
 Sets the cell location and location offset accordingly.
 Pixel coordinate system: origin at the left upper vertex of
 the game grid window, x-axis to the left, y-axis downwards.<br><br>
 Keep in mind the changing the location offset only effects the
 display position and the actorTouchArea (collisionAreas are unchanged).
 Used to fine tune the displayed sprite position in a coarse game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>imageCenter</CODE> - the pixel coordinates of the image center</DL>
</DD>
</DL>
<HR>

<A NAME="getX()"><!-- --></A><H3>
getX</H3>
<PRE>
public int <B>getX</B>()</PRE>
<DL>
<DD>Returns the current horizontal coordinate.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the x-coordinate (cell index)</DL>
</DD>
</DL>
<HR>

<A NAME="getY()"><!-- --></A><H3>
getY</H3>
<PRE>
public int <B>getY</B>()</PRE>
<DL>
<DD>Returns the current vertical coordinate.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the y-coordinate (cell index)</DL>
</DD>
</DL>
<HR>

<A NAME="getLocation()"><!-- --></A><H3>
getLocation</H3>
<PRE>
public <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A> <B>getLocation</B>()</PRE>
<DL>
<DD>Returns the current location (horizontal and vertical coordinates).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a clone of the location (cell indices)</DL>
</DD>
</DL>
<HR>

<A NAME="getLocationStart()"><!-- --></A><H3>
getLocationStart</H3>
<PRE>
public <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A> <B>getLocationStart</B>()</PRE>
<DL>
<DD>Returns the start location (horizontal and vertical coordinates).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a clone of the location when the actor was added to the game grid</DL>
</DD>
</DL>
<HR>

<A NAME="getXStart()"><!-- --></A><H3>
getXStart</H3>
<PRE>
public int <B>getXStart</B>()</PRE>
<DL>
<DD>Returns the x-coordinate of the start location.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the x-coordinate when the actor was added to the game grid</DL>
</DD>
</DL>
<HR>

<A NAME="getYStart()"><!-- --></A><H3>
getYStart</H3>
<PRE>
public int <B>getYStart</B>()</PRE>
<DL>
<DD>Returns the y-coordinate of the start location.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the y-coordinate when the actor was added to the game grid</DL>
</DD>
</DL>
<HR>

<A NAME="getDirectionStart()"><!-- --></A><H3>
getDirectionStart</H3>
<PRE>
public double <B>getDirectionStart</B>()</PRE>
<DL>
<DD>Returns the start direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the start direction when the actor was added to the game grid</DL>
</DD>
</DL>
<HR>

<A NAME="setDirection(double)"><!-- --></A><H3>
setDirection</H3>
<PRE>
public void <B>setDirection</B>(double&nbsp;direction)</PRE>
<DL>
<DD>Sets the moving direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - the angle for the next movement (in degrees clockwise, 0 to east)</DL>
</DD>
</DL>
<HR>

<A NAME="setDirection(ch.aplu.android.Location.CompassDirection)"><!-- --></A><H3>
setDirection</H3>
<PRE>
public void <B>setDirection</B>(<A HREF="../../../ch/aplu/android/Location.CompassDirection.html" title="enum in ch.aplu.android">Location.CompassDirection</A>&nbsp;compassDir)</PRE>
<DL>
<DD>Sets the moving direction to the given compass direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>compassDir</CODE> - the compass dirction for the next movement</DL>
</DD>
</DL>
<HR>

<A NAME="getRotationIndex()"><!-- --></A><H3>
getRotationIndex</H3>
<PRE>
public int <B>getRotationIndex</B>()</PRE>
<DL>
<DD>Returns the current rotation index for rotatable actors.
 By default the rotation index is within 0..59, because
 there are 60 different rotation images  giving an angle
 resolution of  360 / 60 = 6 degrees.
 (This number may be changed using a special GameGrid constructor.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the rotation index (for non-rotatable actors always 0)</DL>
</DD>
</DL>
<HR>

<A NAME="getDirection()"><!-- --></A><H3>
getDirection</H3>
<PRE>
public double <B>getDirection</B>()</PRE>
<DL>
<DD>Gets the current direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the direction for the next movement (in degrees clockwise, 0 to east)</DL>
</DD>
</DL>
<HR>

<A NAME="getIntDirection()"><!-- --></A><H3>
getIntDirection</H3>
<PRE>
public int <B>getIntDirection</B>()</PRE>
<DL>
<DD>Gets the current direction rounded to the next integer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the direction for the next movement (in degrees clockwise, 0 to east)</DL>
</DD>
</DL>
<HR>

<A NAME="getNextMoveLocation()"><!-- --></A><H3>
getNextMoveLocation</H3>
<PRE>
public <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A> <B>getNextMoveLocation</B>()</PRE>
<DL>
<DD>Returns the target location of the next move().
 For a small grid (total number of cells <= 2500 = 50 * 50)
 the target location is one of 8 neighbour cells in the current direction (compass directions 45 degrees wide).
 otherwise it is a cell location about 5 cell sizes away in the current direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="move()"><!-- --></A><H3>
move</H3>
<PRE>
public void <B>move</B>()</PRE>
<DL>
<DD>For a small grid (total number of cells <= 2500 = 50 * 50)
 moves to one of 8 neighbour cells in the current direction (compass directions 45 degrees wide).
 otherwise moves to a cell about 5 cell sizes away in the current direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="move(int)"><!-- --></A><H3>
move</H3>
<PRE>
public void <B>move</B>(int&nbsp;distance)</PRE>
<DL>
<DD>Moves the given distance in the current direction. For distance = 1, the
 8 neighbour locations are reached.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>distance</CODE> - the distance to the requested cell location in cell units.</DL>
</DD>
</DL>
<HR>

<A NAME="getNbHorzCells()"><!-- --></A><H3>
getNbHorzCells</H3>
<PRE>
public int <B>getNbHorzCells</B>()</PRE>
<DL>
<DD>Returns number of cells of actor's game grid in horizontal direction.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of cells in x-direction</DL>
</DD>
</DL>
<HR>

<A NAME="getNbVertCells()"><!-- --></A><H3>
getNbVertCells</H3>
<PRE>
public int <B>getNbVertCells</B>()</PRE>
<DL>
<DD>Returns number of cells of actor's game grid in vertical direction.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of cells in y-direction</DL>
</DD>
</DL>
<HR>

<A NAME="turn(double)"><!-- --></A><H3>
turn</H3>
<PRE>
public void <B>turn</B>(double&nbsp;angle)</PRE>
<DL>
<DD>Turns the moving direction by the given angle (clockwise for positive
 angles, counterclockwise for negative angles). The new moving direction
 remains within 0..360.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>angle</CODE> - the angle to turn in degrees</DL>
</DD>
</DL>
<HR>

<A NAME="act()"><!-- --></A><H3>
act</H3>
<PRE>
public void <B>act</B>()</PRE>
<DL>
<DD>Empty method called in every simulation iteration. Override it to
 implement your own notification.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD>Empty method called when the actor is added to the game grid, 
 the reset button is clicked or doReset() is called.
 Override to get your own notification.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addBorderListener(ch.aplu.android.GGBorderListener)"><!-- --></A><H3>
addBorderListener</H3>
<PRE>
public void <B>addBorderListener</B>(<A HREF="../../../ch/aplu/android/GGBorderListener.html" title="interface in ch.aplu.android">GGBorderListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Registers an GGBorderListener so that the callback method nearBorder() is called
 when the actor's location is on a cell at the border of the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the GGBorderListener to register</DL>
</DD>
</DL>
<HR>

<A NAME="nearBorder(ch.aplu.android.Actor, ch.aplu.android.Location)"><!-- --></A><H3>
nearBorder</H3>
<PRE>
public void <B>nearBorder</B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor,
                       <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</PRE>
<DL>
<DD>Empty implementation of a BorderListener called when the actor is set into a border cell.
 Override to get your own notification.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../ch/aplu/android/GGBorderListener.html#nearBorder(ch.aplu.android.Actor, ch.aplu.android.Location)">nearBorder</A></CODE> in interface <CODE><A HREF="../../../ch/aplu/android/GGBorderListener.html" title="interface in ch.aplu.android">GGBorderListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>actor</CODE> - the current actor<DD><CODE>location</CODE> - the border location</DL>
</DD>
</DL>
<HR>

<A NAME="isInGrid()"><!-- --></A><H3>
isInGrid</H3>
<PRE>
public boolean <B>isInGrid</B>()</PRE>
<DL>
<DD>Returns true, if the actor's location is inside the grid.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the current actor's location is inside the grid</DL>
</DD>
</DL>
<HR>

<A NAME="isNearBorder()"><!-- --></A><H3>
isNearBorder</H3>
<PRE>
public boolean <B>isNearBorder</B>()</PRE>
<DL>
<DD>Returns true, if the current location is on a border row or column.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the current location is on a border row or column</DL>
</DD>
</DL>
<HR>

<A NAME="isMoveValid()"><!-- --></A><H3>
isMoveValid</H3>
<PRE>
public boolean <B>isMoveValid</B>()</PRE>
<DL>
<DD>Returns true, if the next call of move() will put the actor in a cell
 inside the game grid.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the actor remains inside the grid on the next move()</DL>
</DD>
</DL>
<HR>

<A NAME="removeSelf()"><!-- --></A><H3>
removeSelf</H3>
<PRE>
public void <B>removeSelf</B>()</PRE>
<DL>
<DD>Removes the given actor from the scene, so that act() is not called 
 any more. The visiblity is turned off (spriteId = -1) and a registered touch
 or actor touch is disabled.
 If the actor has not yet been added to the game grid, nothing happens.
 Be aware that clicking the reset button or calling reset() will not bring
 the actor to life.<br><br>

 If you want to reuse the removed actor, you may add it again
 to the game grid (the sprite with id = 0 is shown). Any touch or actor touch
 listener must be registered again. Instead of removing the actor,
 call hide() to make him invisible and show() to display him again.<br><br>

 The buffered image resources will be released when the actor
 reference runs out of scope. Because actors use a lot of heap space,
 you should be careful to remove actors and deassign their reference
 when they are no more used (e.g. moves out of the visible game grid).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSlowDown(int)"><!-- --></A><H3>
setSlowDown</H3>
<PRE>
public void <B>setSlowDown</B>(int&nbsp;factor)</PRE>
<DL>
<DD>Slows down the calling of act() by the given factor. This may be used to
 individually adapt the speed of actors. Sets a counter to the given value.
 Before calling act(), the counter is decremented. When it reaches zero,
 act() is called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>factor</CODE> - the factor greater or equal to 1 for delaying the
 invocation of act()</DL>
</DD>
</DL>
<HR>

<A NAME="getSlowDown()"><!-- --></A><H3>
getSlowDown</H3>
<PRE>
public int <B>getSlowDown</B>()</PRE>
<DL>
<DD>Returns the current slow down factor.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the slow down factor</DL>
</DD>
</DL>
<HR>

<A NAME="show()"><!-- --></A><H3>
show</H3>
<PRE>
public void <B>show</B>()</PRE>
<DL>
<DD>Turns on the visibility of the sprite with id 0.
 All other sprites are hidden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="show(int)"><!-- --></A><H3>
show</H3>
<PRE>
public void <B>show</B>(int&nbsp;spriteId)</PRE>
<DL>
<DD>Turns on the visibility of the sprite with given id.
 All other sprites are hidden.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the sprite id that will become visible; visibility
 remains unchanged if spriteId is less than zero or greater or equal to
 the number of sprites</DL>
</DD>
</DL>
<HR>

<A NAME="hide()"><!-- --></A><H3>
hide</H3>
<PRE>
public void <B>hide</B>()</PRE>
<DL>
<DD>Turns off the visiblity of this actor (all sprites are hidden, spriteId = -1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getIdVisible()"><!-- --></A><H3>
getIdVisible</H3>
<PRE>
public int <B>getIdVisible</B>()</PRE>
<DL>
<DD>Returns the id of the visible sprite.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the id of the visible sprite in the range 0..number of
 sprites (exclusive), -1 if no sprite is visible</DL>
</DD>
</DL>
<HR>

<A NAME="isVisible()"><!-- --></A><H3>
isVisible</H3>
<PRE>
public boolean <B>isVisible</B>()</PRE>
<DL>
<DD>Returns true, if the actor is visible.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if one of the sprites is shown; false, if the actor has
 spriteId == -1 or is not part of the game grid</DL>
</DD>
</DL>
<HR>

<A NAME="addCollisionActor(ch.aplu.android.Actor)"><!-- --></A><H3>
addCollisionActor</H3>
<PRE>
public void <B>addCollisionActor</B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;partner)</PRE>
<DL>
<DD>Registers a partner actor that becomes a collision candidate, e.g. that
 is checked for collisions in every simulation cycle.
 The collisions are reported by a collision listener that must be
 registered with addActorCollisionListener().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>partner</CODE> - the partner that is checked for collision</DL>
</DD>
</DL>
<HR>

<A NAME="collide(ch.aplu.android.Actor, ch.aplu.android.Actor)"><!-- --></A><H3>
collide</H3>
<PRE>
public int <B>collide</B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor1,
                   <A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor2)</PRE>
<DL>
<DD>Empty implementation of a GGActorCollisionListener called when the two actors collides.
 Override to get your own notification.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../ch/aplu/android/GGActorCollisionListener.html#collide(ch.aplu.android.Actor, ch.aplu.android.Actor)">collide</A></CODE> in interface <CODE><A HREF="../../../ch/aplu/android/GGActorCollisionListener.html" title="interface in ch.aplu.android">GGActorCollisionListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>actor1</CODE> - the first actor<DD><CODE>actor2</CODE> - the second actor
<DT><B>Returns:</B><DD>nb of simulation cycles to wait until collision is rearmed</DL>
</DD>
</DL>
<HR>

<A NAME="collide(ch.aplu.android.Actor, ch.aplu.android.Location)"><!-- --></A><H3>
collide</H3>
<PRE>
public int <B>collide</B>(<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&nbsp;actor,
                   <A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</PRE>
<DL>
<DD>Empty implementation of a GGTileCollisionListener called when
 the an actor collides with a tile.
 Override to get your own notification.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../ch/aplu/android/GGTileCollisionListener.html#collide(ch.aplu.android.Actor, ch.aplu.android.Location)">collide</A></CODE> in interface <CODE><A HREF="../../../ch/aplu/android/GGTileCollisionListener.html" title="interface in ch.aplu.android">GGTileCollisionListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>actor</CODE> - the colliding actor<DD><CODE>location</CODE> - the location of the colliding tile within the tile map
<DT><B>Returns:</B><DD>nb of simulation cycles to wait until collision is rearmed</DL>
</DD>
</DL>
<HR>

<A NAME="addCollisionActors(java.util.ArrayList)"><!-- --></A><H3>
addCollisionActors</H3>
<PRE>
public void <B>addCollisionActors</B>(java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt;&nbsp;partnerList)</PRE>
<DL>
<DD>Registers all actors in a list as collision candidates.
 The collisions are reported by a collision listener that must be
 registered with addActorCollisionListener().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>partnerList</CODE> - a list of actors that are checked for collision</DL>
</DD>
</DL>
<HR>

<A NAME="getCollisionActors()"><!-- --></A><H3>
getCollisionActors</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt; <B>getCollisionActors</B>()</PRE>
<DL>
<DD>Returns a list of partners that are collision candidates.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>all actors that are checked for collisions</DL>
</DD>
</DL>
<HR>

<A NAME="addCollisionTile(ch.aplu.android.Location)"><!-- --></A><H3>
addCollisionTile</H3>
<PRE>
public void <B>addCollisionTile</B>(<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;location)</PRE>
<DL>
<DD>Registers a tile location that becomes a collision candidate, e.g. that
 is checked for collisions in every simulation cycle.
 The collisions are reported by a collision listener that must be
 registered with addTileCollisionListener().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - the location of the tile within the tile map</DL>
</DD>
</DL>
<HR>

<A NAME="addCollisionTiles(java.util.ArrayList)"><!-- --></A><H3>
addCollisionTiles</H3>
<PRE>
public void <B>addCollisionTiles</B>(java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&gt;&nbsp;locationList)</PRE>
<DL>
<DD>Registers all tile locations in a list as collision candidates.
 The collisions are reported by a collision listener that must be
 registered with addTileCollisionListener().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>locationList</CODE> - a list of tile locations that are checked for collision</DL>
</DD>
</DL>
<HR>

<A NAME="getCollisionTiles()"><!-- --></A><H3>
getCollisionTiles</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&gt; <B>getCollisionTiles</B>()</PRE>
<DL>
<DD>Returns a list of tile locations that are collision candidates.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>all tile locations that are checked for collisions</DL>
</DD>
</DL>
<HR>

<A NAME="addActorCollisionListener(ch.aplu.android.GGActorCollisionListener)"><!-- --></A><H3>
addActorCollisionListener</H3>
<PRE>
public void <B>addActorCollisionListener</B>(<A HREF="../../../ch/aplu/android/GGActorCollisionListener.html" title="interface in ch.aplu.android">GGActorCollisionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Registers a collision listener that reports collision events when
 actors collide. Another already registered listener is disabled. The
 collision notification is called in every simulation cycle before
 the actor's act().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - an actor collision listener; null to disable events</DL>
</DD>
</DL>
<HR>

<A NAME="addTileCollisionListener(ch.aplu.android.GGTileCollisionListener)"><!-- --></A><H3>
addTileCollisionListener</H3>
<PRE>
public void <B>addTileCollisionListener</B>(<A HREF="../../../ch/aplu/android/GGTileCollisionListener.html" title="interface in ch.aplu.android">GGTileCollisionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Registers a tile listener that reports collision events when actors
 and tiles collide. Another already registered listener is disabled.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - a tile collision listener; null to disable events</DL>
</DD>
</DL>
<HR>

<A NAME="setHorzMirror(boolean)"><!-- --></A><H3>
setHorzMirror</H3>
<PRE>
public void <B>setHorzMirror</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD>If set, the sprite image shown is mirrored horizontally.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - if true, horizontal mirroring is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="setVertMirror(boolean)"><!-- --></A><H3>
setVertMirror</H3>
<PRE>
public void <B>setVertMirror</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD>If set, the sprite image shown is mirrored vertically.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - if true, vertical mirroring is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="isHorzMirror()"><!-- --></A><H3>
isHorzMirror</H3>
<PRE>
public boolean <B>isHorzMirror</B>()</PRE>
<DL>
<DD>Returns the horizontal mirroring state.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the sprite is mirrored horizontally; otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="isVertMirror()"><!-- --></A><H3>
isVertMirror</H3>
<PRE>
public boolean <B>isVertMirror</B>()</PRE>
<DL>
<DD>Returns the vertical mirroring state.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the sprite is mirrored vertically; otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="setActEnabled(boolean)"><!-- --></A><H3>
setActEnabled</H3>
<PRE>
public void <B>setActEnabled</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD>Enable/disable the invocation of act() in every simulation cycle.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - if true, act() is invoked; otherwise act() is not invoked</DL>
</DD>
</DL>
<HR>

<A NAME="isActEnabled()"><!-- --></A><H3>
isActEnabled</H3>
<PRE>
public boolean <B>isActEnabled</B>()</PRE>
<DL>
<DD>Returns true, if act() is invoked in every simulation cycle.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if act() is called; false if the invokation of act() is disabled</DL>
</DD>
</DL>
<HR>

<A NAME="setActorCollisionEnabled(boolean)"><!-- --></A><H3>
setActorCollisionEnabled</H3>
<PRE>
public void <B>setActorCollisionEnabled</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD>Enable/disable the detection of collisions with the actor collision candidates.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - if true, collisions will be notified</DL>
</DD>
</DL>
<HR>

<A NAME="isActorCollisionEnabled()"><!-- --></A><H3>
isActorCollisionEnabled</H3>
<PRE>
public boolean <B>isActorCollisionEnabled</B>()</PRE>
<DL>
<DD>Returns true, if collision notification between actors is enabled.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if collision detection is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="getCollisionActorsInRange(double, java.lang.Class, int)"><!-- --></A><H3>
getCollisionActorsInRange</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt; <B>getCollisionActorsInRange</B>(double&nbsp;radius,
                                                            java.lang.Class&nbsp;clazz,
                                                            int&nbsp;spriteId)</PRE>
<DL>
<DD>Returns all collision candidates who belongs to a given class whose collision areas
 of the image with given sprite id intersects the circle with specified radius. Also actors whose cell locations are outside the visible grid are considered.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>radius</CODE> - the radius of the circle around the center of the current location in (fractional) cell units<DD><CODE>clazz</CODE> - the clazz the actors must belong to, if null, all actors are considered
<DT><B>Returns:</B><DD>the list of actors within the given distance</DL>
</DD>
</DL>
<HR>

<A NAME="getNeighbours(double, java.lang.Class)"><!-- --></A><H3>
getNeighbours</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt; <B>getNeighbours</B>(double&nbsp;distance,
                                                java.lang.Class&nbsp;clazz)</PRE>
<DL>
<DD>Returns all actors of specified class in a specified distance.
 The distance defines a circle around the current cell center. All actors in cells that intersects
 with this circle are returned. Also cells outside the visible grid are considered.
 To restrict this list to actors inside the grid, use isInGrid().
 To get the 8 nearest neighbours, use distance = 1, to exclude diagonal
 locations, use distance = 0.5;
 Actors at the current location are not considered.
 Requires that the actor has been added to the game grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>distance</CODE> - the distance in (fractional) cell units  public<DD><CODE>clazz</CODE> - the class of the actors to look for; if null actors of all classes are included</DL>
</DD>
</DL>
<HR>

<A NAME="getNeighbours(double)"><!-- --></A><H3>
getNeighbours</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../ch/aplu/android/Actor.html" title="class in ch.aplu.android">Actor</A>&gt; <B>getNeighbours</B>(double&nbsp;distance)</PRE>
<DL>
<DD>Returns all actors in a specified distance.
 The distance defines a circle around the current cell center. All actors in cells that intersects
 with this circle are returned. Also cells outside the visible grid are considered.
 To restrict this list to actors inside the grid, use isInGrid().
 To get the 6 nearest neighbours, use distance = 1, to exlude diagonal
 locations, use distance = 0.5;
 Actors at the current location are not considered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>distance</CODE> - the distance in (fractional) cell units  public</DL>
</DD>
</DL>
<HR>

<A NAME="isRotatable()"><!-- --></A><H3>
isRotatable</H3>
<PRE>
public boolean <B>isRotatable</B>()</PRE>
<DL>
<DD>Returns whether the actor is rotatable or not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if rotatable, e.g. image rotates when direction changes</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionRectangle(int, android.graphics.Point, int, int)"><!-- --></A><H3>
setCollisionRectangle</H3>
<PRE>
public void <B>setCollisionRectangle</B>(int&nbsp;spriteId,
                                  android.graphics.Point&nbsp;center,
                                  int&nbsp;width,
                                  int&nbsp;height)</PRE>
<DL>
<DD>Selects the rectangle (in pixel units) relative to the sprite image that is used for
 collision detection. The following coordinate system is used:<br><br>
 x-axis to the left, y-axis downward, zero at image center<br><br>
 (For even image pixel width or height, the center is half pixel width
 to the left or resp. to the top). If auto zoom is enabled, the
 rectangle is displaced and zoomed accordingly.br><br>
 Any collision types defined earlier are removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite<DD><CODE>center</CODE> - the rectangle center (zero at image center)<DD><CODE>width</CODE> - the width in pixel units of the rectangle (in x-direction)<DD><CODE>height</CODE> - the height in pixel units of the rectangle (in y-direction)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionRectangle(android.graphics.Point, int, int)"><!-- --></A><H3>
setCollisionRectangle</H3>
<PRE>
public void <B>setCollisionRectangle</B>(android.graphics.Point&nbsp;center,
                                  int&nbsp;width,
                                  int&nbsp;height)</PRE>
<DL>
<DD>Same as setCollisionRectangle(int spriteId, Rectangle rect)
 for spriteId = 0
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - the rectangle center (zero at image center)<DD><CODE>width</CODE> - the width in pixel units of the rectangle (in x-direction)<DD><CODE>height</CODE> - the height in pixel units of the rectangle (in y-direction)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionCircle(int, android.graphics.Point, int)"><!-- --></A><H3>
setCollisionCircle</H3>
<PRE>
public void <B>setCollisionCircle</B>(int&nbsp;spriteId,
                               android.graphics.Point&nbsp;center,
                               int&nbsp;radius)</PRE>
<DL>
<DD>Selects the circle (in pixel units) relative to the sprite image that is used for
 collision detection. The following coordinate system is used:<br><br>
 x-axis to the left, y-axis downward, zero at image center<br><br>
 (for even image pixel width or height, the center is half pixel width
 to the left or resp. to the top). If auto zoom is enabled, the
 circle is displaced and zoomed accordingly.<br><br>
 Any collision types defined earlier are removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite<DD><CODE>center</CODE> - circle center (zero at image center)<DD><CODE>radius</CODE> - the radius of the circle (in pixel units)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionCircle(android.graphics.Point, int)"><!-- --></A><H3>
setCollisionCircle</H3>
<PRE>
public void <B>setCollisionCircle</B>(android.graphics.Point&nbsp;center,
                               int&nbsp;radius)</PRE>
<DL>
<DD>Same as setCollisionCircle(int spriteId, Point center, int radius)
 for spriteId = 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - the circle center (zero at image center)<DD><CODE>radius</CODE> - the radius of the circle (in pixel units)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionLine(int, android.graphics.Point, android.graphics.Point)"><!-- --></A><H3>
setCollisionLine</H3>
<PRE>
public void <B>setCollisionLine</B>(int&nbsp;spriteId,
                             android.graphics.Point&nbsp;startPoint,
                             android.graphics.Point&nbsp;endPoint)</PRE>
<DL>
<DD>Selects the line segment (in pixel units) relative to the sprite image that is used for
 collision detection. The following coordinate system is used:<br><br>
 x-axis to the left, y-axis downward, zero at image center<br><br>
 (for even image pixel width or height, the center is half pixel width
 to the left or resp. to the top). If auto zoom is enabled, the
 line is displaced and zoomed accordingly.<br><br>
 Any collision types defined earlier are removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite<DD><CODE>startPoint</CODE> - the start point of the line (zero at image center)<DD><CODE>endPoint</CODE> - the end point of the line (zero at image center)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionLine(android.graphics.Point, android.graphics.Point)"><!-- --></A><H3>
setCollisionLine</H3>
<PRE>
public void <B>setCollisionLine</B>(android.graphics.Point&nbsp;startPoint,
                             android.graphics.Point&nbsp;endPoint)</PRE>
<DL>
<DD>Same as setCollisionLine(int spriteId, Point startPoint, Point endPoint)
 for spriteId = 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>startPoint</CODE> - the start point of the line (zero at image center)<DD><CODE>endPoint</CODE> - the end point of the line (zero at image center)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionSpot(int, android.graphics.Point)"><!-- --></A><H3>
setCollisionSpot</H3>
<PRE>
public void <B>setCollisionSpot</B>(int&nbsp;spriteId,
                             android.graphics.Point&nbsp;spot)</PRE>
<DL>
<DD>Selects the hot spot (in pixel units) relative to the sprite image that is used for
 collision detection. The following coordinate system is used:<br><br>
 x-axis to the left, y-axis downward, zero at image center<br><br>
 (for even image pixel width or height, the center is half pixel
 width to the left or resp. to the top). If auto zoom is enabled, the
 spot is displaced accordingly.<br><br>
 Any collision types defined earlier are removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite<DD><CODE>spot</CODE> - the hot spot (zero at image center)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionSpot(android.graphics.Point)"><!-- --></A><H3>
setCollisionSpot</H3>
<PRE>
public void <B>setCollisionSpot</B>(android.graphics.Point&nbsp;spot)</PRE>
<DL>
<DD>Same as setCollisionSpot(int spriteId, Point spot)
 for spriteId = 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spot</CODE> - the hot spot (zero at image center)</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionImage(int)"><!-- --></A><H3>
setCollisionImage</H3>
<PRE>
public void <B>setCollisionImage</B>(int&nbsp;spriteId)</PRE>
<DL>
<DD>Selects collision detection on non-transparent pixels of the image.
 Due to performance reasons only available if the collision partner
 detects collision using spot, circle or line detection.
 Any collision types defined earlier are removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionImage()"><!-- --></A><H3>
setCollisionImage</H3>
<PRE>
public void <B>setCollisionImage</B>()</PRE>
<DL>
<DD>Same as setCollisionImage(int spriteId) for spriteId = 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOnTop()"><!-- --></A><H3>
setOnTop</H3>
<PRE>
public void <B>setOnTop</B>()</PRE>
<DL>
<DD>Sets the actor at the first place in the scene <b>of the actor's class</b>.
 Consequently the actor act() method will be called first and the actor image
 will be drawn on top of all other actor images <b>for this class</b>. The order
 of the other actors remains unchanged. To change the act or paint order of
 the actors class, use GameGrid.setActOrder() or GameGrid.setPaintOrder().
 Requires that the actor has been added to the game grid.<br><br>
 If you want to change the paint order of actors in different actor classes,
 use GameGrid.setPaintOrder().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../ch/aplu/android/GameGrid.html#setPaintOrder(java.lang.Class...)"><CODE>GameGrid.setPaintOrder(Class... classes)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOnBottom()"><!-- --></A><H3>
setOnBottom</H3>
<PRE>
public void <B>setOnBottom</B>()</PRE>
<DL>
<DD>Sets the actor at the last place in the scene <b>of the actor's class</b>.
 Consequently the actor act() method will be called last and the actor image
 will be drawn on the bottom of all other actor images <b>for this class</b>. The order
 of the other actors remains unchanged. To change the act or paint order of
 the actors class, use GameGrid.setActOrder() or GameGrid.setPaintOrder().
 Requires that the actor has been added to the game grid.<br><br>
 If you want to change the paint order of actors in different actor classes,
 use GameGrid.setPaintOrder().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../ch/aplu/android/GameGrid.html#setPaintOrder(java.lang.Class...)"><CODE>GameGrid.setPaintOrder(Class... classes)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getNbCycles()"><!-- --></A><H3>
getNbCycles</H3>
<PRE>
public int <B>getNbCycles</B>()</PRE>
<DL>
<DD>Returns the number of simulation cycles since last reset.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of simulation cycles</DL>
</DD>
</DL>
<HR>

<A NAME="delay(long)"><!-- --></A><H3>
delay</H3>
<PRE>
public static void <B>delay</B>(long&nbsp;time)</PRE>
<DL>
<DD>Delay execution for the given amount of time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the delay time (in ms)</DL>
</DD>
</DL>
<HR>

<A NAME="showNextSprite()"><!-- --></A><H3>
showNextSprite</H3>
<PRE>
public void <B>showNextSprite</B>()</PRE>
<DL>
<DD>Increases the id of the currently visible sprite and makes this
 sprite visible.
 If spriteId reaches nbSprites - 1 the next sprite id will be 0.
 If spriteId is -1 (sprite invisible) the next sprite id is 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="showPreviousSprite()"><!-- --></A><H3>
showPreviousSprite</H3>
<PRE>
public void <B>showPreviousSprite</B>()</PRE>
<DL>
<DD>Decreases the id of the currently visible sprite and makes this
 sprite visible.
 If spriteId reaches 0 the previous sprite id will be nbSprites - 1.
 If spriteId is -1 (sprite invisible) the previous sprite id is still -1.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCurrentImage()"><!-- --></A><H3>
getCurrentImage</H3>
<PRE>
public android.graphics.Bitmap <B>getCurrentImage</B>()</PRE>
<DL>
<DD>Returns the bitmap of the currently visible sprite picture.
 If the actor is rotatable, this is the rotated image and it's size
 (bounding rectangle) is bigger than the originally loaded image.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the bitmap of the displayed sprite picture.</DL>
</DD>
</DL>
<HR>

<A NAME="getImage(int)"><!-- --></A><H3>
getImage</H3>
<PRE>
public android.graphics.Bitmap <B>getImage</B>(int&nbsp;spriteId)</PRE>
<DL>
<DD>Returns the bitmap of the originally loaded sprite with
 given sprite id. Unmodified when the actor is rotatable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the bitmap of the loaded sprite.</DL>
</DD>
</DL>
<HR>

<A NAME="getImage()"><!-- --></A><H3>
getImage</H3>
<PRE>
public android.graphics.Bitmap <B>getImage</B>()</PRE>
<DL>
<DD>Returns the bitmap of the originally loaded sprite with
 id = 0. Unmodified when the actor is rotatable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the bitmap of the sprite with id = 0</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelColor(android.graphics.Point)"><!-- --></A><H3>
getPixelColor</H3>
<PRE>
public int <B>getPixelColor</B>(android.graphics.Point&nbsp;pt)</PRE>
<DL>
<DD>Returns the color of the currently visible sprite image at given
 pixel position ((0,0) at upper left vertex, x-axis to the right,
 y-axis downwards).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pt</CODE> - the point where to look for the color
<DT><B>Returns:</B><DD>the image color of the given point returned by BufferedImage.getRGB()</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelLocation()"><!-- --></A><H3>
getPixelLocation</H3>
<PRE>
public android.graphics.Point <B>getPixelLocation</B>()</PRE>
<DL>
<DD>Returns the location of the actor center in pixel coordinates taking
 into account the current location offset (default offset is 0).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the pixel coordinates with respect to the game grid window
 (origin at upper left vertex, x-axis to the left, y-axis downward);
 null, if the actor is not yet added to the game grid<DT><B>See Also:</B><DD><A HREF="../../../ch/aplu/android/Actor.html#setLocationOffset(android.graphics.Point)"><CODE>setLocationOffset(Point locationOffset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getWidth(int)"><!-- --></A><H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>(int&nbsp;spriteId)</PRE>
<DL>
<DD>Returns the width of the sprite with given id.
 This is the width of the originally loaded sprited image. (For
 rotatable actors the bounding rectangle is increased to give space
 for the rotated images.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite
<DT><B>Returns:</B><DD>The width in pixels of this sprite</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight(int)"><!-- --></A><H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>(int&nbsp;spriteId)</PRE>
<DL>
<DD>Returns the height of the sprite with given id.
 This is the height of the originally loaded sprited image. (For
 rotatable actors the bounding rectangle is increased to give space
 for the rotated images.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite
<DT><B>Returns:</B><DD>The height in pixels of this sprite</DL>
</DD>
</DL>
<HR>

<A NAME="getRotatedPosition(ch.aplu.android.GGVector, android.graphics.Point, double)"><!-- --></A><H3>
getRotatedPosition</H3>
<PRE>
public static <A HREF="../../../ch/aplu/android/GGVector.html" title="class in ch.aplu.android">GGVector</A> <B>getRotatedPosition</B>(<A HREF="../../../ch/aplu/android/GGVector.html" title="class in ch.aplu.android">GGVector</A>&nbsp;position,
                                          android.graphics.Point&nbsp;center,
                                          double&nbsp;angle)</PRE>
<DL>
<DD>Returns a new position vector of given position vector
 rotated with given center point by given angle.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the vector to the current position<DD><CODE>center</CODE> - the rotation center point<DD><CODE>angle</CODE> - the rotating angle (in degrees, positive clockwise)
<DT><B>Returns:</B><DD>the position (vector with double precision) to the rotated position</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(ch.aplu.android.Location, double)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(<A HREF="../../../ch/aplu/android/Location.html" title="class in ch.aplu.android">Location</A>&nbsp;centerLoc,
                   double&nbsp;angle)</PRE>
<DL>
<DD>Rotates the actor with given rotation center location by the given angle.
 The rotated location is approximate due to the grid resolution.
 If a precise sequence of rotations with the same rotation center is needed,
 use getRotatedPosition(Point center, GGVector position, double angle)
 with a global center and position.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>centerLoc</CODE> - the rotation center location<DD><CODE>angle</CODE> - the rotation angle (in degrees, positive clockwise)</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(android.graphics.Point, double)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(android.graphics.Point&nbsp;center,
                   double&nbsp;angle)</PRE>
<DL>
<DD>Rotates the actor with given rotation center point by given angle.
 The rotated location is approximate due to the grid resolution.
 If a precise sequence of rotations with the same rotation center is needed,
 use getRotatedPosition(Point center, GGVector position, double angle)
 with a global center and position.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - the rotation center point<DD><CODE>angle</CODE> - the rotation angle (in degrees, positive clockwise)</DL>
</DD>
</DL>
<HR>

<A NAME="addActorTouchListener(ch.aplu.android.GGActorTouchListener, int)"><!-- --></A><H3>
addActorTouchListener</H3>
<PRE>
public void <B>addActorTouchListener</B>(<A HREF="../../../ch/aplu/android/GGActorTouchListener.html" title="interface in ch.aplu.android">GGActorTouchListener</A>&nbsp;listener,
                                  int&nbsp;touchEventMask)</PRE>
<DL>
<DD>Same as addActorTouchListener(listener, touchEventMask, onTopOnly)
 with onTopOnly = false.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the GGActorTouchListener to register<DD><CODE>touchEventMask</CODE> - an OR-combinaton of constants defined in class GGTouch</DL>
</DD>
</DL>
<HR>

<A NAME="addActorTouchListener(ch.aplu.android.GGActorTouchListener, int, boolean)"><!-- --></A><H3>
addActorTouchListener</H3>
<PRE>
public void <B>addActorTouchListener</B>(<A HREF="../../../ch/aplu/android/GGActorTouchListener.html" title="interface in ch.aplu.android">GGActorTouchListener</A>&nbsp;listener,
                                  int&nbsp;touchEventMask,
                                  boolean&nbsp;onTopOnly)</PRE>
<DL>
<DD>Add a GGActionTouchListener to get notifications when the touch
 interacts with the actor touch area.
 Only the events defined as OR-combination in the specified mask
 are notified. Touch area types available: IMAGE
 (default, events on non-transparent pixels of sprite image),
 RECTANGLE, CIRCLE. The non-default types can be selected for each sprite ID
 with Actor.setTouchRectangle(), Actor.setTouchCircle().<br><br>
 The touch must be enabled and the touch event not "consumed"
 by other touch event callbacks. The sequence of events from several
 registered listeners is not previsible.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the GGActorTouchListener to register<DD><CODE>touchEventMask</CODE> - an OR-combinaton of constants defined in class GGTouch<DD><CODE>onTopOnly</CODE> - if true, enable actor touch event for the actor at top of others
 (painted last) only; otherwise touch event of all actors is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchRectangle(int, android.graphics.Point, int, int)"><!-- --></A><H3>
setActorTouchRectangle</H3>
<PRE>
public void <B>setActorTouchRectangle</B>(int&nbsp;spriteId,
                                   android.graphics.Point&nbsp;center,
                                   int&nbsp;width,
                                   int&nbsp;height)</PRE>
<DL>
<DD>Selects the rectangle (in pixel units) relative to the sprite image that is used for
 actor touch detection. The following coordinate system is used:<br><br>
 x-axis to the left, y-axis downward, zero at image center<br><br>
 (For even image pixel width or height, the center is half pixel width
 to the left or resp. to the top). If auto zoom is enabled, the
 rectangle is displaced and zoomed accordingly.<br><br>
 Any touch type defined earlier is replaced.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite<DD><CODE>center</CODE> - the rectangle center (zero at image center)<DD><CODE>width</CODE> - the width in pixel units of the rectangle (in x-direction)<DD><CODE>height</CODE> - the height in pixel units of the rectangle (in y-direction)</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchRectangle(android.graphics.Point, int, int)"><!-- --></A><H3>
setActorTouchRectangle</H3>
<PRE>
public void <B>setActorTouchRectangle</B>(android.graphics.Point&nbsp;center,
                                   int&nbsp;width,
                                   int&nbsp;height)</PRE>
<DL>
<DD>Same as setActorTouchRectangle(int spriteId, Rectangle rect)
 for all sprites of this actor.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - the rectangle center (zero at image center)<DD><CODE>width</CODE> - the width in pixel units of the rectangle (in x-direction)<DD><CODE>height</CODE> - the height in pixel units of the rectangle (in y-direction)</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchCircle(int, android.graphics.Point, int)"><!-- --></A><H3>
setActorTouchCircle</H3>
<PRE>
public void <B>setActorTouchCircle</B>(int&nbsp;spriteId,
                                android.graphics.Point&nbsp;center,
                                int&nbsp;radius)</PRE>
<DL>
<DD>Selects the circle (in pixel units) relative to the sprite image that is used for
 actor touch detection. The following coordinate system is used:<br><br>
 x-axis to the left, y-axis downward, zero at image center<br><br>
 (for even image pixel width or height, the center is half pixel width
 to the left or resp. to the top). If auto zoom is enabled, the
 circle is displaced and zoomed accordingly.<br><br>
 Any interaction type defined earlier is replaced.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the id of the sprite<DD><CODE>center</CODE> - circle center (zero at image center)<DD><CODE>radius</CODE> - the radius of the circle (in pixel units)</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchCircle(android.graphics.Point, int)"><!-- --></A><H3>
setActorTouchCircle</H3>
<PRE>
public void <B>setActorTouchCircle</B>(android.graphics.Point&nbsp;center,
                                int&nbsp;radius)</PRE>
<DL>
<DD>Same as setActorTouchCircle(int spriteId, Point center, int radius)
 for all sprites of this actor.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - circle center (zero at image center)<DD><CODE>radius</CODE> - the radius of the circle (in pixel units)</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchImage(int)"><!-- --></A><H3>
setActorTouchImage</H3>
<PRE>
public void <B>setActorTouchImage</B>(int&nbsp;spriteId)</PRE>
<DL>
<DD>Selects the non-transparent pixels of the sprite image for
 actor touch detection. This is the default detection
 type when the GGActorTouchListener is registered.<br><br>
 Any interaction type defined earlier is replaced.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchImage()"><!-- --></A><H3>
setActorTouchImage</H3>
<PRE>
public void <B>setActorTouchImage</B>()</PRE>
<DL>
<DD>Same as setActorTouchImage(int spriteId) for all sprites of this actor.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setActorTouchEnabled(boolean)"><!-- --></A><H3>
setActorTouchEnabled</H3>
<PRE>
public void <B>setActorTouchEnabled</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD>Enable/disable the detection of actor touch interactions.
 Default: true
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - if true, actor touch interactions will be notified</DL>
</DD>
</DL>
<HR>

<A NAME="getZoomedImage(android.graphics.Bitmap, double)"><!-- --></A><H3>
getZoomedImage</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static android.graphics.Bitmap <B>getZoomedImage</B>(android.graphics.Bitmap&nbsp;bitmap,
                                                                double&nbsp;factor)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use GGBitmap.getZoomedImage instead. <A HREF="../../../ch/aplu/android/GGBitmap.html#getZoomedImage(android.graphics.Bitmap, double)"><CODE>GGBitmap.getZoomedImage(Bitmap bitmap, double factor)</CODE></A></I>
<P>
<DD>Returns the sprite image scaled by the given factor.
 The returned image can be used to create a new actor with a zoomed and
 rotated image.<br><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bitmap</CODE> - the original sprite image bitmap<DD><CODE>factor</CODE> - the zoom factor (>1 zoom-in, <1 zoom-out)
<DT><B>Returns:</B><DD>the transformed sprite image bitmap</DL>
</DD>
</DL>
<HR>

<A NAME="getRotatedImage(android.graphics.Bitmap, double)"><!-- --></A><H3>
getRotatedImage</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static android.graphics.Bitmap <B>getRotatedImage</B>(android.graphics.Bitmap&nbsp;bitmap,
                                                                 double&nbsp;angle)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use GGBitmap.getRotatedImage instead. <A HREF="../../../ch/aplu/android/GGBitmap.html#getRotatedImage(android.graphics.Bitmap, double)"><CODE>GGBitmap.getRotatedImage(Bitmap bitmap, double angle)</CODE></A></I>
<P>
<DD>Returns the sprite image rotated by the given angle.
 The returned image can be used to create a new actor with a zoomed and
 rotated image.<br><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bitmap</CODE> - the original sprite image bitmap<DD><CODE>angle</CODE> - the rotation angle (in degrees clockwise)
<DT><B>Returns:</B><DD>the transformed sprite image bitmap</DL>
</DD>
</DL>
<HR>

<A NAME="getScaledImage(android.graphics.Bitmap, double, double)"><!-- --></A><H3>
getScaledImage</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static android.graphics.Bitmap <B>getScaledImage</B>(android.graphics.Bitmap&nbsp;bitmap,
                                                                double&nbsp;factor,
                                                                double&nbsp;angle)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use GGBitmap.getScaledImage instead. <A HREF="../../../ch/aplu/android/GGBitmap.html#getScaledImage(android.graphics.Bitmap, double, double)"><CODE>GGBitmap.getScaledImage(Bitmap bitmap, double factor, double angle)</CODE></A></I>
<P>
<DD>Returns the sprite image scaled by the given factor and rotated by the given angle.
 The returned image can be used to create a new actor with a zoomed and
 rotated image.<br><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bitmap</CODE> - the original sprite image bitmap<DD><CODE>factor</CODE> - the zoom factor (>1 zoom-in, <1 zoom-out)<DD><CODE>angle</CODE> - the rotation angle (in degrees clockwise)
<DT><B>Returns:</B><DD>the transformed sprite image bitmap</DL>
</DD>
</DL>
<HR>

<A NAME="getScaledImage(int, double, double)"><!-- --></A><H3>
getScaledImage</H3>
<PRE>
public android.graphics.Bitmap <B>getScaledImage</B>(int&nbsp;spriteId,
                                              double&nbsp;factor,
                                              double&nbsp;direction)</PRE>
<DL>
<DD>Returns the sprite image scaled by the given factor and rotated to the
 given direction.
 The returned image can be used to create a new actor with a zoomed and
 rotated image.<br><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>spriteId</CODE> - the sprite id of the actor's sprite image<DD><CODE>factor</CODE> - the zoom factor (>1 zoom-in, <1 zoom-out)<DD><CODE>direction</CODE> - the rotation angle (in degrees clockwise, 0 to east)
<DT><B>Returns:</B><DD>the transformed image</DL>
</DD>
</DL>
<HR>

<A NAME="getScaledImage(double, double)"><!-- --></A><H3>
getScaledImage</H3>
<PRE>
public android.graphics.Bitmap <B>getScaledImage</B>(double&nbsp;factor,
                                              double&nbsp;direction)</PRE>
<DL>
<DD>Same as getScaledImage(int spriteId, double factor, double direction)
 with spriteId = 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>factor</CODE> - the zoom factor (>1 zoom-in, <1 zoom-out)
<DT><B>Returns:</B><DD>the transformed image</DL>
</DD>
</DL>
<HR>

<A NAME="getNbSprites()"><!-- --></A><H3>
getNbSprites</H3>
<PRE>
public int <B>getNbSprites</B>()</PRE>
<DL>
<DD>Returns number of sprites.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of sprites</DL>
</DD>
</DL>
<HR>

<A NAME="isRemoved()"><!-- --></A><H3>
isRemoved</H3>
<PRE>
public boolean <B>isRemoved</B>()</PRE>
<DL>
<DD>Returns true, if the actor has been removed (by calling removeSelf() or
 GameGrid.removeActor()). If the actor was never part of the game grid
 or is added again to the game grid after being removed, returns false.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the actor has been removed</DL>
</DD>
</DL>
<HR>

<A NAME="displace(double)"><!-- --></A><H3>
displace</H3>
<PRE>
public void <B>displace</B>(double&nbsp;ds)</PRE>
<DL>
<DD>Increases the current double displace position in the 
 current direction to the given double distance and moves the actor 
 in the cell that contains the given coordinates. Sets the location 
 offset accordingly.<br>
 The displace position uses a double coordinate system corresponing to
 the integer pixel coordinates. This method is convenient to move 
 the actor as precise as possible on a straight line even in a coarse grid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ds</CODE> - the distance to displace the actor; if negative, displace in
 opposite direction</DL>
</DD>
</DL>
<HR>

<A NAME="getDisplacePosition()"><!-- --></A><H3>
getDisplacePosition</H3>
<PRE>
public <A HREF="../../../ch/aplu/android/PointD.html" title="class in ch.aplu.android">PointD</A> <B>getDisplacePosition</B>()</PRE>
<DL>
<DD>Returns the current displace position.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current displace position</DL>
</DD>
</DL>
<HR>

<A NAME="setDisplacePosition(ch.aplu.android.PointD)"><!-- --></A><H3>
setDisplacePosition</H3>
<PRE>
public void <B>setDisplacePosition</B>(<A HREF="../../../ch/aplu/android/PointD.html" title="class in ch.aplu.android">PointD</A>&nbsp;displacePosition)</PRE>
<DL>
<DD>Sets the current displace position and moves the actor in the cell that
 contains the given coordinates. Sets the location offset accordingly.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>displacePosition</CODE> - the double coordinates of the new position</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Actor.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../ch/aplu/android/ConsoleActivity.html" title="class in ch.aplu.android"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?ch/aplu/android/Actor.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Actor.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
